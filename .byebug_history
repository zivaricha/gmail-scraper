cont
next
cont
scraped_transaction
next
cont
user_transaction
next
cont
Time.now
user
next
exit
exception
next
cont
exit
current_user.expired?
current_user
exit
exception
next
cont
exception
next
exit
message.id
cont
next
cont
exit
exception
next
exit
links_nodeset[4].text
next
doc.css(".product-name")[0].text.strip
doc.css(".product-name")[0]
next
scraped_transaction
next
doc
next
scraped_transaction
next
full_message
next
cont
exception
next
service
next
cont
next
exit
exception
next
cont
exception
next
cont
user.gmail_access_token
user
next
exit
exception
next
cont
next
user
next
cont
exit
exception
next
user
next
access_token.info
cont
exit
request.env['omniauth.auth']
@user
next
exit
result
@message_date
next
cont
@message_date
next
cont
exit
x=full_message.payload.headers.select {|t| t.name =="zDate"}[0]
x=full_message.payload.headers.select {|t| t.name =="zDate"}
x.first.value.to_date
x.first.value
x.first
x.value
x=full_message.payload.headers.select {|t| t.name =="Date"}
full_message.payload.headers.select {|t| t.name =="Date"}
full_message.payload.headers.collect {|t| t.name}
Time.at(full_message.internal_date).to_date
next
cont
exit
Time.at(full_message.internal_date).to_date
Time.at(full_message.internal_date)
Time.now(full_message.internal_date)
full_message.internal_date
full_message.methods
next
cont
fll_message
@seller_name
next
@product_name
next
@price
next
cont
@product_name
@seller_name
next
product_name_node.text.strip
product_name_node.text
product_name_node
@product_name
next
match_data[0].to_f
next
cont
@seller_name
next
@product_name
next
@price
next
 match_data[0].to_f if match_data.present? && match_data[0].present?
next
cont
next
cont
@token.id
exit
full_message.payload.headers.collect {|t,i| [t.name,i]}
full_message.payload.headers.collect {|t| t.name}
full_message.payload.headers[3].name
full_message.payload.headers[3]
full_message.payload.headers[2]
full_message.payload.headers[1]
full_message.payload.headers.first
full_message.payload.headers
full_message.payload.headers.keys
full_message.methods
.methds
full_message
doc.css(".product-price").select{ |node| node.text.upcase.include? "PAID"}[0].text
doc.css(".product-price").select{ |node| node.text.upcase.include? "PAID"}.text
doc.css(".product-price").select{ |node| node.text.upcase.include? "PAID"}
@product_name
@price
next
cont
next
 doc.css("a")[4].text
doc
next
doc
 doc.css("a")[4].text
next
cont
 doc.css("a")[4].text
 doc.css("a")[4]
 doc.css("a")
next
full_message.payload.parts.first.body.data
full_message.payload.parts.first.body
full_message.payload.parts.first
full_message.payload.parts
full_message.payload
full_message
doc
 doc.css("a")[4].text
next
cont
doc.css("a")[4].text
doc.css("a")[3].text
doc.css("a")[2].text
doc.css("a")[2]
doc.css("a")[0].text
doc.css("a")[0]
doc.css("a")[1]
doc.css("a").size
doc.css("a")
product_name_node = doc.css(".product-name")[0]
product_name_node = doc.css(".product-name")[0].children.children
product_name_node = doc.css(".product-name")[0].children
product_name_node = doc.css(".product-name")[0].childen
product_name_node = doc.css(".product-name")[0].childrn
product_name_node = doc.css(".product-name")[0]
doc.css()[0]
doc.css(".ziv")[0]
doc.css(".ziv")
doc.css(".product-name")[1].text
doc.css(".product-name")[0].text
doc.css(".product-name")[0]
price
next
price.to_i
price
next
cont
exit
x.size
x=doc.css(".product-price").select{ |node| node.text.upcase.include? "PAID"}
doc.css(".product-price").select{ |node| node.text.upcase.include? "PAID"}
doc.css(".product-price").size
doc.css(".product-name")[1].text
doc.css(".product-name")[0].text
doc.css(".product-name")[2].text
doc.css(".product-name")[2]
doc.css(".product-name").second.text
doc.css(".product-name").first.text
doc.css(".product-name").first
doc.css(".product-name").first.text
doc.css(".product-name").first
doc.css(".product-name")
doc.css(".product-name").size
doc.css(".product-name").first
doc.css(".product-name").class
doc.css(".product-name")
/asd/.match("asd")[0]
/asd/.match("asd")
/\d+(\.\d{1,2})?/.match(node.text)
/\d+(\.\d{1,2})?/.match(node.text)[1]
/\d+(\.\d{1,2})?/.match(node.text)[0]
/\d+(\.\d{1,2})?/.match(node.text).text
/\d+(\.\d{1,2})?/.match(node.text).to_i
/\d+(\.\d{1,2})?/.match(node.text)
/b/.match(node.text)
/a/.match(node.text)
/\d+(,\d{1,2})?/.match(node.text)
/\d+(.\dd{1,2})?/.match(node.text)
/\d+(.\d{1,2})?/.match(node.text)
node.text.upcase
node.text
node
/\d+(.\d{1,2})?/.match(node.text)[0]
/\d+(.\d{1,2})?/.match(node.text)
/})?$/.match(node.text)
/6.49/.match(node.text)[0]
/6.495/.match(node.text)
/6.49/.match(node.text)
/49/.match(node.text)
/6/.match(node.text)
/^6$/.match(node.text)
